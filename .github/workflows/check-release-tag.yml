# .github/workflows/check-release-tag.yml
name: Check Release Status for Main Merge

on:
    pull_request:
        types: [opened, synchronize, reopened] # åŠ å…¥ reopened ä»¥ç¢ºä¿å®Œæ•´è¦†è“‹
        branches:
            - main # Only for PRs targeting the 'main' branch

jobs:
    check_release_tag:
        runs-on: ubuntu-latest
        # This job runs only if the source branch of the PR is 'develop'
        if: github.head_ref == 'develop'

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0 # Fetch full history including all refs (tags, branches) for accurate checks

            # æ˜Žç¢ºæŠ“å–æ‰€æœ‰å¿…è¦çš„åˆ†æ”¯å’Œæ¨™ç±¤
            - name: Fetch all refs from origin
              run: |
                  git fetch origin develop
                  git fetch --tags origin

            - name: Get latest release tag on develop branch
              id: get_tag_develop
              run: |
                  # ä½¿ç”¨æ›´ç²¾ç¢ºçš„æ–¹å¼æŸ¥æ‰¾æœ€æ–°çš„ release æ¨™ç±¤
                  # åªåœ¨ develop åˆ†æ”¯ä¸ŠæŸ¥æ‰¾ï¼Œä¸¦æŽ’åºå–æœ€æ–°çš„
                  latest_tag=$(git tag -l "v*" --sort=-version:refname --merged origin/develop | head -n1 || echo "no_tag")

                  # å¦‚æžœæ²’æ‰¾åˆ°æ¨™ç±¤ï¼Œå†ç”¨ describe è©¦ä¸€æ¬¡
                  if [ "$latest_tag" == "no_tag" ] || [ -z "$latest_tag" ]; then
                      latest_tag=$(git describe --tags --abbrev=0 --match "v*" origin/develop 2>/dev/null || echo "no_tag")
                  fi

                  echo "Latest tag found on 'origin/develop': $latest_tag"
                  echo "latest_tag=${latest_tag}" >> "$GITHUB_OUTPUT"

            - name: Get develop branch HEAD commit SHA
              id: get_develop_head
              run: |
                  develop_head_commit=$(git rev-parse origin/develop)
                  echo "Develop HEAD commit SHA: ${develop_head_commit}"
                  echo "develop_head_commit=${develop_head_commit}" >> "$GITHUB_OUTPUT"

            - name: Check if latest tag points to develop HEAD
              id: check_tag_at_head
              env:
                  LATEST_TAG: ${{ steps.get_tag_develop.outputs.latest_tag }}
                  DEVELOP_HEAD_COMMIT: ${{ steps.get_develop_head.outputs.develop_head_commit }}
              run: |
                  ERROR_MESSAGE=""
                  echo "error_detected=false" >> "$GITHUB_OUTPUT"

                  if [ "$LATEST_TAG" == "no_tag" ] || [ -z "$LATEST_TAG" ]; then
                      ERROR_MESSAGE="âŒ **No release tag found on develop branch**

                      This indicates that no official release has been performed on 'develop' yet.

                      **Required Action:**
                      1. Wait for release-please to create a Release PR on develop branch
                      2. Review and merge the Release PR
                      3. This will create a new release tag on develop
                      4. Then retry this PR to main"

                      echo "::error::${ERROR_MESSAGE}"
                      echo "error_message=${ERROR_MESSAGE}" >> "$GITHUB_OUTPUT"
                      echo "error_detected=true" >> "$GITHUB_OUTPUT"
                      exit 0
                  fi

                  # ç²å–æ¨™ç±¤æŒ‡å‘çš„ commit SHA
                  tag_commit=$(git rev-parse "refs/tags/${LATEST_TAG}" 2>/dev/null || echo "")

                  if [ -z "$tag_commit" ]; then
                      ERROR_MESSAGE="âŒ **Release tag '${LATEST_TAG}' not found or invalid**

                      The tag may have been deleted or corrupted.

                      **Required Action:**
                      Please check the release status on develop branch and ensure the tag exists."

                      echo "::error::${ERROR_MESSAGE}"
                      echo "error_message=${ERROR_MESSAGE}" >> "$GITHUB_OUTPUT"
                      echo "error_detected=true" >> "$GITHUB_OUTPUT"
                      exit 0
                  fi

                  echo "Tag '${LATEST_TAG}' points to commit: ${tag_commit}"
                  echo "Develop HEAD is at commit: ${DEVELOP_HEAD_COMMIT}"

                  # é—œéµæª¢æŸ¥ï¼šæ¨™ç±¤æ˜¯å¦æŒ‡å‘ develop çš„ HEAD
                  if [ "$tag_commit" != "$DEVELOP_HEAD_COMMIT" ]; then
                      # æª¢æŸ¥æ˜¯å¦æœ‰æœªç™¼å¸ƒçš„ commits
                      commits_ahead=$(git rev-list --count "${LATEST_TAG}..origin/develop" 2>/dev/null || echo "unknown")

                      ERROR_MESSAGE="âŒ **Develop branch has unreleased changes**

                      The latest release tag '${LATEST_TAG}' does not point to the current HEAD of develop branch.

                      **Details:**
                      - Latest release tag: \`${LATEST_TAG}\` (${tag_commit:0:8})
                      - Develop HEAD: \`${DEVELOP_HEAD_COMMIT:0:8}\`
                      - Commits ahead of release: ${commits_ahead}

                      **Required Action:**
                      1. Check for a pending Release PR created by release-please on develop
                      2. If exists, review and merge it to create a new release
                      3. If no Release PR exists, push a new commit to develop to trigger release-please
                      4. Then retry this PR to main"

                      echo "::error::${ERROR_MESSAGE}"
                      echo "error_message=${ERROR_MESSAGE}" >> "$GITHUB_OUTPUT"
                      echo "error_detected=true" >> "$GITHUB_OUTPUT"
                      exit 0
                  fi

                  echo "âœ… Success: develop branch HEAD is properly tagged with release '${LATEST_TAG}'"
                  echo "The develop branch is ready for squash merge to main."

            - name: Validate release-please commit pattern
              id: validate_release_commit
              if: ${{ steps.check_tag_at_head.outputs.error_detected == 'false' }}
              env:
                  LATEST_TAG: ${{ steps.get_tag_develop.outputs.latest_tag }}
                  DEVELOP_HEAD_COMMIT: ${{ steps.get_develop_head.outputs.develop_head_commit }}
              run: |
                  # æª¢æŸ¥ HEAD commit æ˜¯å¦çœ‹èµ·ä¾†åƒ release-please çš„ commit
                  commit_message=$(git log -1 --pretty=format:"%s" "$DEVELOP_HEAD_COMMIT")
                  echo "HEAD commit message: $commit_message"

                  # release-please é€šå¸¸æœƒç”¢ç”Ÿé¡žä¼¼ "chore(main): release 1.0.0" çš„ commit message
                  if echo "$commit_message" | grep -qE "(chore\(main\)|release|Release)" || \
                     echo "$commit_message" | grep -qE "^v?[0-9]+\.[0-9]+\.[0-9]+"; then
                      echo "âœ… HEAD commit appears to be from release-please: '$commit_message'"
                  else
                      echo "âš ï¸  Warning: HEAD commit doesn't match typical release-please pattern"
                      echo "This might be okay if your release process is different"
                  fi

            - name: Post PR comment on failure
              if: ${{ steps.check_tag_at_head.outputs.error_detected == 'true' }}
              uses: actions/github-script@v7
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const errorMessage = `${{ steps.check_tag_at_head.outputs.error_message }}`;
                      const message = `## ðŸš« PR Merge Blocked - Release Required

                      This Pull Request from \`develop\` to \`main\` cannot be merged because:

                      ${errorMessage}

                      ---

                      ### ðŸ”„ How to resolve:

                      1. **Check for Release PR**: Look for an open PR on \`develop\` created by \`release-please\`
                      2. **Merge Release PR**: Review and merge it to create a new release tag
                      3. **Wait for tag**: Ensure the new tag appears on develop's HEAD commit
                      4. **Retry**: Push a new commit to this PR or close/reopen to re-trigger checks

                      ### ðŸ“‹ Understanding the process:

                      Since you're using **squash and merge**, the \`main\` branch will only see a single summarized commit (like "Release: my first version"). This workflow ensures that only properly released code from \`develop\` gets merged to \`main\`.

                      ---
                      *This check ensures release integrity with your squash-and-merge strategy* ðŸ›¡ï¸`;

                      // Check if a similar comment already exists
                      const { data: comments } = await github.rest.issues.listComments({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: context.issue.number,
                      });

                      const existingComment = comments.find(comment =>
                        comment.user.login === 'github-actions[bot]' &&
                        comment.body.includes('ðŸš« PR Merge Blocked - Release Required')
                      );

                      if (existingComment) {
                        console.log('Updating existing blocking comment...');
                        await github.rest.issues.updateComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          comment_id: existingComment.id,
                          body: message
                        });
                      } else {
                        console.log('Creating new blocking comment...');
                        await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: context.issue.number,
                          body: message
                        });
                      }

            - name: Block merge if not properly released
              if: ${{ steps.check_tag_at_head.outputs.error_detected == 'true' }}
              run: |
                  echo "::error::Blocking merge: develop branch is not in a properly released state"
                  exit 1

            - name: Success summary
              if: ${{ steps.check_tag_at_head.outputs.error_detected == 'false' }}
              run: |
                  echo "::notice::âœ… All checks passed! Develop branch is ready for squash merge to main"
                  echo "The release tag properly marks the HEAD of develop branch"
